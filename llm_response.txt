### FILE: offscreen.js

// Listen for messages from the background script
chrome.runtime.onMessage.addListener(async (message) =\> {
if (message.target \!== 'offscreen') return;

if (message.action === 'START') {
startRecording(message.streamId);
} else if (message.action === 'STOP') {
stopRecording();
}
});

let audioContext;
let mediaStream;
let audioWorkletNode;
let mp3Encoder;
let dataBuffer = [];
let sampleRate = 44100;
let kbps = 128;

async function startRecording(streamId) {
try {
if (typeof lamejs === 'undefined') {
throw new Error('lamejs library not found. Please ensure lib/lame.min.js is populated.');
}

```
// Acquire media stream
mediaStream = await navigator.mediaDevices.getUserMedia({
  audio: {
    mandatory: {
      chromeMediaSource: 'tab',
      chromeMediaSourceId: streamId
    }
  },
  video: false
});

// Initialize Audio Context
// Use the system sample rate to avoid resampling artifacts/issues
audioContext = new AudioContext(); 
sampleRate = audioContext.sampleRate;
await audioContext.resume();

// Load the AudioWorklet processor
try {
  await audioContext.audioWorklet.addModule('recorder-processor.js');
} catch (e) {
  throw new Error('Failed to load recorder-processor.js: ' + e.message);
}

const source = audioContext.createMediaStreamSource(mediaStream);

mp3Encoder = new lamejs.Mp3Encoder(1, sampleRate, kbps);
dataBuffer = []; 

audioWorkletNode = new AudioWorkletNode(audioContext, 'recorder-processor');

audioWorkletNode.port.onmessage = (event) => {
  const inputData = event.data;
  if (!inputData) return;

  const inputInt16 = convertFloat32ToInt16(inputData);
  
  // lamejs expects Int16Array
  const mp3Data = mp3Encoder.encodeBuffer(inputInt16);
  if (mp3Data.length > 0) {
    dataBuffer.push(mp3Data);
  }
};

source.connect(audioWorkletNode);
audioWorkletNode.connect(audioContext.destination);

console.log('Recording started. Sample rate:', sampleRate);
```

} catch (err) {
console.error('Error starting recording:', err);
chrome.runtime.sendMessage({
action: 'ERROR',
error: err.message
});
}
}

function stopRecording() {
if (audioWorkletNode) {
audioWorkletNode.disconnect();
audioWorkletNode = null;
}

if (mediaStream) {
mediaStream.getTracks().forEach(track =\> track.stop());
mediaStream = null;
}

// Finalize MP3 encoding
if (mp3Encoder) {
const mp3Data = mp3Encoder.flush();
if (mp3Data.length \> 0) {
dataBuffer.push(mp3Data);
}
mp3Encoder = null;
}

if (audioContext) {
audioContext.close();
audioContext = null;
}

if (dataBuffer.length === 0) {
console.warn('Buffer is empty. No audio recorded.');
chrome.runtime.sendMessage({
action: 'ERROR',
error: 'No audio data captured. Check if audio is playing or lamejs is working.'
});
return;
}

const blob = new Blob(dataBuffer, { type: 'audio/mp3' });

const reader = new FileReader();
reader.onload = function() {
chrome.runtime.sendMessage({
action: 'SAVE\_RECORDING',
data: reader.result
});
dataBuffer = [];
};
reader.readAsDataURL(blob);
}

function convertFloat32ToInt16(float32Array) {
const len = float32Array.length;
const int16Array = new Int16Array(len);
for (let i = 0; i \< len; i++) {
let s = Math.max(-1, Math.min(1, float32Array[i]));
int16Array[i] = s \< 0 ? s \* 0x8000 : s \* 0x7FFF;
}
return int16Array;
}

### ENDFILE

### FILE: background.js

let recordingState = false;

chrome.runtime.onMessage.addListener(async (message, sender, sendResponse) =\> {
if (message.action === 'START\_RECORDING') {
await startRecording(message.streamId);
sendResponse({ success: true });
} else if (message.action === 'STOP\_RECORDING') {
await stopRecording();
sendResponse({ success: true });
} else if (message.action === 'SAVE\_RECORDING') {
handleSave(message.data);
} else if (message.action === 'GET\_STATUS') {
sendResponse({ isRecording: recordingState });
} else if (message.action === 'ERROR') {
console.error('Offscreen Error:', message.error);
// Optionally notify user via badge or notification
chrome.action.setBadgeText({ text: 'ERR' });
chrome.action.setBadgeBackgroundColor({ color: '\#000000' });
}
});

async function startRecording(streamId) {
if (recordingState) return;

const existingContexts = await chrome.runtime.getContexts({
contextTypes: ['OFFSCREEN\_DOCUMENT']
});

if (existingContexts.length === 0) {
await chrome.offscreen.createDocument({
url: 'offscreen.html',
reasons: ['USER\_MEDIA'],
justification: 'Recording tab audio'
});
}

chrome.runtime.sendMessage({
target: 'offscreen',
action: 'START',
streamId: streamId
});

recordingState = true;
chrome.action.setBadgeText({ text: 'REC' });
chrome.action.setBadgeBackgroundColor({ color: '\#FF0000' });
}

async function stopRecording() {
if (\!recordingState) return;

chrome.runtime.sendMessage({
target: 'offscreen',
action: 'STOP'
});

recordingState = false;
chrome.action.setBadgeText({ text: '' });
}

function handleSave(base64Data) {
const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
const filename = `recording-${timestamp}.mp3`;

chrome.downloads.download({
url: base64Data,
filename: filename,
saveAs: false
});
}

### ENDFILE

### FILE: tasks.md

# CRITICAL ERROR

  - [x] The MP3 generated by this extension has zerp bytes. no errors shown in the browser console logs or in the UI.

# Tasks

  - [x] Initialize project structure (`manifest.json`, `background.js`, `popup.html`).
  - [x] Implement Offscreen API setup (`offscreen.html`, `offscreen.js`).
  - [x] Implement Audio Capture logic using `chrome.tabCapture` and `getUserMedia`.
  - [x] Implement MP3 Encoding logic (Stubbed `lamejs` integration).
  - [x] Implement Background Service Worker to handle messages and downloads.
  - [x] Implement Popup UI for Start/Stop controls.
  - [x] Handle file saving via `chrome.downloads`.

## Backlog

  - [x] Add `lame.min.js` to `lib/` (External dependency required for MP3 encoding).
  - [x] Refactor `ScriptProcessorNode` to `AudioWorklet` (Performance optimization).
  - [ ] Add visualization (waveform) to Popup UI.
  - [ ] Handle very long recordings (Chunked transfer between Offscreen and Background to avoid Base64 string limits).
  - [ ] Improve Error UI in Popup (currently errors only log to console/badge).

### ENDFILE

### COMMIT: fix: handle zero-byte mp3 issue by validating inputs and reporting errors to background