### FILE: recorder-processor.js

class RecorderProcessor extends AudioWorkletProcessor {
constructor() {
super();
this.bufferSize = 4096;
this.\_buffer = new Float32Array(this.bufferSize);
this.\_bytesWritten = 0;
}

process(inputs, outputs, parameters) {
const input = inputs[0];
// input is array of channels, input[0] is Float32Array of samples
if (input && input.length \> 0) {
const channelData = input[0];

```
  for (let i = 0; i < channelData.length; i++) {
    this._buffer[this._bytesWritten++] = channelData[i];

    if (this._bytesWritten >= this.bufferSize) {
      // Send a copy of the buffer to the main thread
      this.port.postMessage(this._buffer.slice(0, this.bufferSize));
      this._bytesWritten = 0;
    }
  }
}
return true; // Keep processor alive
```

}
}

registerProcessor('recorder-processor', RecorderProcessor);

### ENDFILE

### FILE: offscreen.js

// Listen for messages from the background script
chrome.runtime.onMessage.addListener(async (message) =\> {
if (message.target \!== 'offscreen') return;

if (message.action === 'START') {
startRecording(message.streamId);
} else if (message.action === 'STOP') {
stopRecording();
}
});

let audioContext;
let mediaStream;
let audioWorkletNode;
let mp3Encoder;
let dataBuffer = [];
let sampleRate = 44100;
let kbps = 128;

async function startRecording(streamId) {
try {
// Acquire media stream using the ID passed from popup -\> background -\> here
mediaStream = await navigator.mediaDevices.getUserMedia({
audio: {
mandatory: {
chromeMediaSource: 'tab',
chromeMediaSourceId: streamId
}
},
video: false
});

```
// Initialize Audio Context
audioContext = new AudioContext({ sampleRate: sampleRate });

// Load the AudioWorklet processor
await audioContext.audioWorklet.addModule('recorder-processor.js');

const source = audioContext.createMediaStreamSource(mediaStream);

// Initialize LameJS Encoder
if (typeof lamejs === 'undefined') {
  console.error('lamejs not found. Please populate lib/lame.min.js');
  return;
}

mp3Encoder = new lamejs.Mp3Encoder(1, sampleRate, kbps);
dataBuffer = []; // Clear buffer

// Create AudioWorkletNode
audioWorkletNode = new AudioWorkletNode(audioContext, 'recorder-processor');

// Handle audio data from the worklet
audioWorkletNode.port.onmessage = (event) => {
  const inputData = event.data; // Float32Array from processor
  
  // Convert Float32 to Int16 for LameJS
  const inputInt16 = convertFloat32ToInt16(inputData);
  
  // Encode
  const mp3Data = mp3Encoder.encodeBuffer(inputInt16);
  if (mp3Data.length > 0) {
    dataBuffer.push(mp3Data);
  }
};

source.connect(audioWorkletNode);
audioWorkletNode.connect(audioContext.destination); // Play audio to user while recording
```

} catch (err) {
console.error('Error starting recording:', err);
}
}

function stopRecording() {
if (audioWorkletNode) {
audioWorkletNode.disconnect();
audioWorkletNode = null;
}

if (audioContext) {
audioContext.close();
audioContext = null;
}

if (mediaStream) {
mediaStream.getTracks().forEach(track =\> track.stop());
mediaStream = null;
}

// Finalize MP3 encoding
if (mp3Encoder) {
const mp3Data = mp3Encoder.flush();
if (mp3Data.length \> 0) {
dataBuffer.push(mp3Data);
}
mp3Encoder = null;
}

// Create Blob
const blob = new Blob(dataBuffer, { type: 'audio/mp3' });

// Convert to Base64 to send to Background
const reader = new FileReader();
reader.onload = function() {
chrome.runtime.sendMessage({
action: 'SAVE\_RECORDING',
data: reader.result // Data URL
});
// Clear buffer after save
dataBuffer = [];
};
reader.readAsDataURL(blob);
}

function convertFloat32ToInt16(float32Array) {
const len = float32Array.length;
const int16Array = new Int16Array(len);
for (let i = 0; i \< len; i++) {
// Clamp values to [-1, 1]
let s = Math.max(-1, Math.min(1, float32Array[i]));
// Scale to 16-bit signed integer range
int16Array[i] = s \< 0 ? s \* 0x8000 : s \* 0x7FFF;
}
return int16Array;
}

### ENDFILE

### FILE: tasks.md

# Tasks

  - [x] Initialize project structure (`manifest.json`, `background.js`, `popup.html`).
  - [x] Implement Offscreen API setup (`offscreen.html`, `offscreen.js`).
  - [x] Implement Audio Capture logic using `chrome.tabCapture` and `getUserMedia`.
  - [x] Implement MP3 Encoding logic (Stubbed `lamejs` integration).
  - [x] Implement Background Service Worker to handle messages and downloads.
  - [x] Implement Popup UI for Start/Stop controls.
  - [x] Handle file saving via `chrome.downloads`.

## Backlog

  - [x] Add `lame.min.js` to `lib/` (External dependency required for MP3 encoding).
  - [x] Refactor `ScriptProcessorNode` to `AudioWorklet` (Performance optimization).
  - [ ] Add visualization (waveform) to Popup UI.
  - [ ] Handle very long recordings (Chunked transfer between Offscreen and Background to avoid Base64 string limits).

### ENDFILE

### COMMIT: refactor: replace ScriptProcessorNode with AudioWorklet for performance optimization